(self.webpackChunkbugu=self.webpackChunkbugu||[]).push([[8971],{744:(e,n,i)=>{"use strict";i.r(n),i.d(n,{data:()=>t});const t={key:"v-68b2200f",path:"/old_blog/ios%20%E5%8A%A8%E6%80%81%E6%B5%8B%E5%AE%9A%E5%AD%97%E7%AC%A6%E4%B8%B2frame%20%E2%80%94%E2%80%94%20boundingRectWithSize%E5%87%BD%E6%95%B0.html",title:"",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[],filePathRelative:"old_blog/ios 动态测定字符串frame —— boundingRectWithSize函数.md",git:{updatedTime:1597237797e3}}},9339:(e,n,i)=>{"use strict";i.r(n),i.d(n,{default:()=>s});const t=(0,i(6252).uE)('<p>动态测定字符串frame，用NSString中的一个方法<code>boundingRectWithSize</code>函数</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>    NSDictionary * dic = [NSDictionary dictionaryWithObject: [UIFont systemFontOfSize:14] forKey:NSFontAttributeName];\n    CGSize size = CGSizeMake(230, 1500);\n    CGRect rect = [string boundingRectWithSize:size\n                                       options:NSStringDrawingTruncatesLastVisibleLine|NSStringDrawingUsesFontLeading|NSStringDrawingUsesLineFragmentOrigin\n                                    attributes:dic\n                                       context:nil];\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>第一个参数是text形成的<code>frame</code>的最大的宽度和高度, 其中的<code>options</code>比较关键</p><ul><li><p><code>NSStringDrawingUsesLineFragmentOrigin</code> 多行绘制必有选项，不然测量的frame是单行文字的frame</p></li><li><p><code>NSStringDrawingUsesFontLeading</code> 决定行高的确定方法</p></li><li><p><code>NSStringDrawingTruncatesLastVisibleLine</code> 多行模式下，最后一行显示不下时，采用截断方式显示，就是显示...</p></li></ul><p>一般的文字frame计算，都需要上面3个选项！</p>',5),s={render:function(e,n){return t}}}}]);